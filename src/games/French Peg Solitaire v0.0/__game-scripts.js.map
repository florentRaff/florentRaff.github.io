{"version":3,"sources":["scripts/game_logic.js","marble.js","raycast.js","hideAtLaunch.js","gridBlocks/gridBlock.js","scripts/platformCollider.js","scripts/history.js"],"names":[],"mappings":"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","sourcesContent":["// game_logic.js\nvar gl = pc.createScript('game_logic'); // here the name of the script 'gamelogic' to create an instance of the script\n\n/*\nTODO LIST\n- imagining an environment with pebbles, sand, and water passing around the pebbles and the deck, and you see little foamy bits instanced and traveling around\nedges of things then dissipating\n  - equivalently something with plants and light wind, all giving a mauritius vibe and also with audio reactivity like in my koi pond\n\n\n- start looking into publishing with play canvas and a website and ads etc...\n- then and you win and you loose screens\n- and only after that add camera movement\n- I think it would be really satisfying to see the marbles move out of the way a tiny bit from the one you've selected, it would have to always move the shortest distance from it's address it can to avoid the selected marble. So there's some math there I think. Not sure how much computation that might require as well.\n- then also multiple selections\n\n\n*/\n\n// ATTRIBUTES__________________________________\ngl.attributes.add(\"gridBlockMaterials\", {type: \"asset\", assetType: \"material\", array: true, title: \"gridBlockMaterials\"});\ngl.attributes.add('mainCam', {\n  type: 'entity', \n  default: null\n});\ngl.attributes.add('marbleTemplateId', {\n  type: 'number',\n  default: 91480630\n});\ngl.attributes.add('gridBlockId', {\n  type: 'number',\n  default: 92322602\n});\ngl.prototype.setupAndLocalVariables = function() {\n  // LOCAL VARIABLES___________________________________________________________________________\n  this.clickedMarble = {};\n  this.currentScannedBlock = {};\n  this.previousScannedBlock = {};\n  this.currentScannedMarble = {};\n  this.previousScannedMarble = {};\n  this.lastBlock = {};\n  this.nextBlockCandidate = {};\n  this.mousePos = [0,0];\n  this.mouseClickRaycastResult = {};\n  this.firstMoveMade = false;\n  // GRID AND MARBLE ARRAY VARS\n  this.gridBlocks = new Array (7).fill({}).map(() => new Array(7).fill({}));\n  this.marbleInstances = new Array(37).fill({});\n  // grabbing the template we want to instantiate\n  this.marbleTemplate = this.app.assets.get(this.marbleTemplateId);\n  this.blockTemplate = this.app.assets.get(this.gridBlockId);\n  \n  // SETTING UP ARRAYS_________________________________________________________________________\n  // looping through 7 rows and 7 columns and \"m\" number of marbles with nested for loops to create grid addresses and instantiate marbles\n  for (let i = 0, m = 0; i < 7; i++) {\n    for (let j = 0; j < 7; j++){\n      if (this.checkIfGridSpotUsable(i,j)) { // if the corresponding position on our 7x7 grid would be on the board\n        // CREATE MARBLES\n        this.marbleInstances[m] = this.marbleTemplate.resource.instantiate();\n        this.app.root.addChild(this.marbleInstances[m]);\n        this.marbleInstances[m].name = 'marble_'+ m;\n        this.marbleInstances[m].script.marble.id = m;\n        this.marbleInstances[m].script.marble.col = j;\n        this.marbleInstances[m].script.marble.row = i;\n        this.marbleInstances[m].script.marble.isSet = true;\n        this.marbleInstances[m].setPosition(j-3, 0.25, i-3);\n        // CREATE GRID BLOCKS\n        this.gridBlocks[i][j] = this.blockTemplate.resource.instantiate();\n        this.app.root.addChild(this.gridBlocks[i][j]);\n        this.gridBlocks[i][j].name = \"gridBlock_row_\" + i + \"_col_\" + j;\n        this.gridBlocks[i][j].setPosition(j-3, 0.01, i-3);\n        this.gridBlocks[i][j].script.gridBlock.isUsable = true;\n        this.gridBlocks[i][j].script.gridBlock.isUsed = true;\n        this.gridBlocks[i][j].script.gridBlock.row = i;\n        this.gridBlocks[i][j].script.gridBlock.col = j;\n        this.gridBlocks[i][j].script.gridBlock.marbleId = m;\n        // console.log(this.gridBlocks[i][j].children);\n        this.toggleGridBlockChildren(this.gridBlocks[i][j], false);\n        m++;\n      } else {\n        this.gridBlocks[i][j] = this.blockTemplate.resource.instantiate();\n        this.app.root.addChild(this.gridBlocks[i][j]);\n        this.gridBlocks[i][j].name = \"gridBlock_row_\" + i + \"_col_\" + j;\n        this.gridBlocks[i][j].setPosition(j-3, 0.01, i-3);\n        this.gridBlocks[i][j].script.gridBlock.isUsable = false;\n        this.gridBlocks[i][j].collision.enabled = false;\n        this.toggleGridBlockChildren(this.gridBlocks[i][j], false);\n        this.gridBlocks[i][j].script.gridBlock.isUsed = false;\n        this.gridBlocks[i][j].script.gridBlock.row = i;\n        this.gridBlocks[i][j].script.gridBlock.col = j;\n      }\n    }\n  }\n};\n\n// STATE MACHINE_____________________________________\ngl.prototype.states = {\n  state: 'gameStart',\n  gameStart: {\n    actions: {\n      onEnter: function(thisgl) { \n        // console.log('gameStart onEnter function'); \n      },\n      onUpdate: function(thisgl) {\n        // search for grid block and store result\n        var raycast = thisgl.doRaycast(thisgl.mousePos[0], thisgl.mousePos[1]); \n        // if a gridblock or empty grid block is found\n        if (raycast.result && raycast.type === 'marble') {\n          thisgl.previousScannedMarble = thisgl.currentScannedMarble;\n          thisgl.currentScannedMarble = raycast.result.entity;\n          if (Object.entries(thisgl.previousScannedMarble).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n            thisgl.previousScannedMarble.setLocalScale(0.5, 0.5, 0.5);\n          }\n          thisgl.currentScannedMarble.setLocalScale(0.55, 0.55, 0.55);\n        } else if (raycast.result && raycast.type === 'gridBlock') {\n          if (Object.entries(thisgl.currentScannedMarble).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n            thisgl.currentScannedMarble.setLocalScale(0.5, 0.5, 0.5);\n          }\n        }\n      },\n      onExit: function(thisgl) { \n        // turn off the visibilit off all grid block crosshairs\n        thisgl.currentScannedMarble.setLocalScale(0.5, 0.5, 0.5);\n      }\n    },\n    events: {\n      marbleClicked: {\n        target: 'idle', //------------------------------------------------------\n        action: function(thisgl) { \n          // remove clicked marble\n          thisgl.removeMarble(thisgl.clickedMarble);\n          // grid block on that row and col is now free\n          thisgl.lastBlock.script.gridBlock.isUsed = false;\n          // first move has been made (this is so rotateView can return to gamestart)\n          thisgl.firstMoveMade = true;\n        }\n      },\n      bgClicked: {\n        target: 'rotateView', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for gameStart > rotateView (from bgClicked event)'); \n        }\n      },\n      gridClicked: {\n        target: 'rotateView', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for gameStart > rotateView (from gridClicked event)' ); \n        }\n      },\n    },\n  },\n  idle: {\n    actions: {\n      onEnter: function(thisgl) { \n        // console.log('idle onEnter function');\n      },\n      onUpdate: function(thisgl) {\n        // search for grid block and store result\n        var raycast = thisgl.doRaycast(thisgl.mousePos[0], thisgl.mousePos[1]); \n        // if a gridblock or empty grid block is found\n        if (raycast.result && raycast.type === 'marble') {\n          thisgl.previousScannedMarble = thisgl.currentScannedMarble;\n          thisgl.currentScannedMarble = raycast.result.entity;\n          if (Object.entries(thisgl.previousScannedMarble).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n            thisgl.previousScannedMarble.setLocalScale(0.5, 0.5, 0.5);\n          }\n          thisgl.currentScannedMarble.setLocalScale(0.55, 0.55, 0.55);\n        } else if (raycast.result && raycast.type === 'gridBlock') {\n          if (Object.entries(thisgl.currentScannedMarble).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n            thisgl.currentScannedMarble.setLocalScale(0.5, 0.5, 0.5);\n          }\n        }\n      },\n      onExit: function(thisgl) { \n        // console.log('idle onExit function'); \n      }\n    },\n    events: {\n      marbleClicked: {\n        target: 'marbleSelected', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for idle > marbleSelected'); \n        }\n      },\n      bgClicked: {\n        target: 'rotateView', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for idle > rotateView (from bgClicked event)'); \n        }\n      },\n      gridClicked: {\n        target: 'rotateView', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for idle > rotateView (from gridClicked event)' ); \n        }\n      },\n      emptySpotClicked: {\n        target: 'rotateView', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for gameStart > rotateView (from gridClicked event)' ); \n        }\n      }\n    }\n  },\n  rotateView:{\n    actions: {\n      onEnter: function(thisgl) { \n        // console.log('rotateView onEnter function'); \n      },\n      onUpdate: {},\n      onExit: function(thisgl) { \n        // console.log('rotateView onExit function'); \n      }\n    },\n    events: {\n      clickReleased: {\n        target: 'idle', //------------------------------------------------------\n        action: function(thisgl) {\n          // console.log('clickReleased in rotateView'); \n        }\n      },\n      gameStartClickReleased: {\n        target: 'gameStart', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for rotateView > gameStart'); \n        }\n      }\n    }\n  },\n  marbleSelected: {\n    actions: {\n      onEnter: function(thisgl) { \n        // turn off marble coliders so we can raycast the different grid blocks\n        thisgl.toggleMarbleColliders(false);\n      },\n      onUpdate: function(thisgl) {\n        // search for grid block and store result\n        var raycast = thisgl.doRaycast(thisgl.mousePos[0], thisgl.mousePos[1]); \n        // if a gridblock or empty grid block is found\n        if (raycast.result && raycast.type === 'gridBlock') {\n          // Set prevoius block, and set current block based on raycast result\n          thisgl.previousScannedBlock = thisgl.currentScannedBlock;\n          thisgl.currentScannedBlock = raycast.result.entity;\n          // ANIMATE CROSSHAIRS\n          thisgl.animateCrosshairs(thisgl.lastBlock, thisgl.previousScannedBlock, thisgl.currentScannedBlock, thisgl.clickedMarble, thisgl.gridBlockMaterials[0], thisgl.gridBlockMaterials[1], thisgl.gridBlockMaterials[2]); \n          // ANIMATE MARBLE\n          thisgl.animateMarble (thisgl.clickedMarble, raycast.result.entity.getPosition(), raycast.result.point);\n        } \n      \n      },\n      onExit: function(thisgl) { \n        // turn marble coliders back on\n        thisgl.toggleMarbleColliders(true); \n        // reset marble scale\n        thisgl.clickedMarble.setLocalScale(0.5,0.5,0.5);\n        // turn off the visibilit off all grid block crosshairs\n        thisgl.turnOffGridBlocksVisibility();\n        thisgl.returnMarble(thisgl.clickedMarble); \n      }\n    },\n    events: {\n      bgClicked: {\n        target: 'idle', //------------------------------------------------------\n        action: function(thisgl) { \n          // console.log('transition action for marbleSelected > idle (bgClicked)');\n          thisgl.returnMarble(thisgl.clickedMarble); \n        }\n      },\n      gridClicked: {\n        target: 'idle', //------------------------------------------------------\n        action: function(thisgl) { \n          // grab new block candidate, get previous block by using current marble's row and col values\n          var nb = thisgl.currentScannedBlock;\n          var pb = thisgl.gridBlocks[thisgl.clickedMarble.script.marble.row][thisgl.clickedMarble.script.marble.col];\n          // if space is two away from marble in horizontal or vertical \n          if (thisgl.canMarbleMoveHere(pb, nb)) {\n            thisgl.moveMarble(pb, nb);\n          } else {\n            thisgl.returnMarble(thisgl.clickedMarble);\n          }\n          // console.log('marbles remaining: ' + thisgl.marblesLeft());  // console.log('marbleClicked state > gridClicked action function');\n          if (!thisgl.anyMovesLeft()) {\n            console.log('no more moves left');\n          } \n        }\n      },\n    }\n  },\n  noMoreMoves: {\n    default: function() { console.log('not yet setup'); }\n  },\n  victory: {\n    default: function() { console.log('not yet setup'); }\n  },\n  // function that figures out what state to change to and what actions to perform based on recieved event\n  event: function(thisgl, eventString) {\n    // old state and event check\n    var oldStateString = this.state;\n    var oldState = this[oldStateString];\n    if (!oldState.events[eventString]) {\n      return;\n    }\n    // old state exit actions\n    oldState.actions.onExit(thisgl);\n    // event transition actions\n    oldState.events[eventString].action(thisgl);\n    // new state \n    newStateString = oldState.events[eventString].target;\n    newState = this[newStateString];\n    // new state actions\n    newState.actions.onEnter(thisgl);\n    // change current state\n    this.state = newStateString;\n    return;\n  }\n};\n\n// METHODS _____________________________________\ngl.prototype.animateMarble = function (marble, currentScannedBlockPos, contactPoint) {\n  var distance = currentScannedBlockPos.distance(contactPoint);\n  // creating snapping behavior for marble movement following cursor and grid\n  if (distance > 0) { // was 0.33\n    // move freely\n    marble.setPosition(contactPoint.x, 0.25, contactPoint.z);\n    marble.setLocalScale(0.5,0.5,0.5);\n  } else {\n    // snap\n    marble.setPosition(currentScannedBlockPos.x, 0.25, currentScannedBlockPos.z);\n    marble.setLocalScale(0.55, 0.55, 0.55);\n  }\n};\ngl.prototype.animateCrosshairs = function (lastBlock, previousScannedBlock, currentScannedBlock, marble, lastBlockMaterial, nextBlockMaterial, cantMoveMaterial) {\n  // last block (clicked marble's block)\n  this.toggleGridBlockChildren(lastBlock, true);\n  this.assignMaterialToChildren(lastBlock, lastBlockMaterial);\n  // previous scanned block\n  if (Object.entries(previousScannedBlock).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n    this.toggleGridBlockChildren(previousScannedBlock, false); // turn off previous block visibility\n  }\n  // current scanned block aka next block candidate\n  this.toggleGridBlockChildren(currentScannedBlock, true); // turn on new current block visibility\n  if (this.canMarbleMoveHere(lastBlock, currentScannedBlock)) { // see if current scanned block is a candidate for moving, and set materials accordingly\n    this.assignMaterialToChildren(currentScannedBlock, nextBlockMaterial);\n  } else {\n    this.assignMaterialToChildren(currentScannedBlock, cantMoveMaterial);\n  }\n};\ngl.prototype.animateCrosshairsOnStart = function (previousScannedBlock, currentScannedBlock, nextBlockMaterial) {\n  // previous scanned block\n  if (Object.entries(previousScannedBlock).length !== 0) { // if previous block is not empty (it will be at the beginning of the game when there is not a current block yet)\n    this.toggleGridBlockChildren(previousScannedBlock, false); // turn off previous block visibility\n  }\n  // current scanned block aka next block candidate\n  this.toggleGridBlockChildren(currentScannedBlock, true); // turn on new current block visibility\n  this.assignMaterialToChildren(currentScannedBlock, nextBlockMaterial);\n};\ngl.prototype.returnMarble = function(marble) {\n  var marblesGridBlockPosition = this.gridBlocks[marble.script.marble.row][marble.script.marble.col].getPosition();\n  marble.setPosition(marblesGridBlockPosition.x, 0.25, marblesGridBlockPosition.z);\n};\ngl.prototype.toggleGridBlockChildren = function (gb, onOff) {\n  var renders = gb.findComponents('render');\n  for (let i = 0; i < renders.length; ++i) {\n    renders[i].enabled = onOff;\n  } \n};\ngl.prototype.assignMaterialToChildren = function (gb, material) {     \n  // Assign the material to all the mesh instances in the model\n  var allMeshInstances = [];\n  var renders = gb.findComponents('render');\n  for (let i = 0; i < renders.length; ++i) {\n      var meshInstances = renders[i].meshInstances;\n      for (let j = 0; j < meshInstances.length; j++) {\n        meshInstances[j].material = material.resource;\n      }\n  }      \n};\ngl.prototype.canMarbleMoveHere = function (lastBlock, nextBlock) {\n  if (!this.currentScannedBlock.script.gridBlock.isUsed) {\n    if (this.checkIf2SpotsAway(lastBlock, nextBlock)) {\n    // calculate middle block\n      var mb = this.calculateMiddleBlock(lastBlock, nextBlock);\n      if (mb.script.gridBlock.isUsed) { // check to make sure we are actually jumping over a marble\n        return true;\n      }\n      else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\ngl.prototype.moveMarble = function (lastBlock, nextBlock) {\n  // middle block and middle marble\n  var mb = this.calculateMiddleBlock(lastBlock, nextBlock);\n  var middleMarble = this.marbleInstances[mb.script.gridBlock.marbleId];\n  mb.script.gridBlock.isUsed = false;\n  // set prior and middle grid block to not used\n  lastBlock = lastBlock.script.gridBlock;\n  nextBlock = nextBlock.script.gridBlock;\n  lastBlock.isUsed = false;\n  nextBlock.isUsed = true;\n  nextBlock.marbleId = this.clickedMarble.script.marble.id;\n  // change marble's row and col addresses, and isSet true \n  this.updateMarble(this.clickedMarble, nextBlock.row, nextBlock.col, true);\n  var nextBlockPos = this.currentScannedBlock.getPosition();\n  this.clickedMarble.setPosition(nextBlockPos.x, 0.25, nextBlockPos.z);\n  // clear marble we jumped over, maybe make a clear/destroy marble function\n  this.removeMarble(this.marbleInstances[mb.script.gridBlock.marbleId]);\n};\ngl.prototype.removeMarble = function (marble) {\n  marble.collision.enabled = false;\n  marble.render.enabled = false;\n  marble.script.marble.isSet = false;\n};\ngl.prototype.updateMarble = function(marble, row, col, isSet){\n  marble = marble.script.marble;\n  marble.row = row;\n  marble.col = col;\n  marble.isSet = isSet;\n};\ngl.prototype.calculateMiddleBlock = function (lastBlock, nextBlock) {\n  lastBlock = lastBlock.script.gridBlock;\n  nextBlock = nextBlock.script.gridBlock;\n  var row = 0;\n  var col = 0;\n  if (nextBlock.row > lastBlock.row) { row = lastBlock.row + 1; } \n  else if (nextBlock.row < lastBlock.row) { row = nextBlock.row + 1; } \n  else { row = nextBlock.row; }\n  if (nextBlock.col > lastBlock.col) { col = lastBlock.col + 1; } \n  else if (nextBlock.col < lastBlock.col) { col = nextBlock.col + 1; } \n  else { col = nextBlock.col; }\n  return this.gridBlocks[row][col];\n};\ngl.prototype.checkIf2SpotsAway = function(lastBlock, nextBlock) {\n  lastBlock = lastBlock.script.gridBlock;\n  nextBlock = nextBlock.script.gridBlock;\n  if ((nextBlock.row === lastBlock.row && (Math.abs(nextBlock.col - lastBlock.col) === 2)) || \n  (nextBlock.col === lastBlock.col && (Math.abs(nextBlock.row - lastBlock.row) === 2))) {\n    return true;\n  } else {\n    return false;\n  }\n};\ngl.prototype.toggleMarbleColliders = function (onOff) {\n  for (let i = 0; i < this.marbleInstances.length; i++) {\n    if (this.marbleInstances[i].script.marble.isSet) {\n          this.marbleInstances[i].collision.enabled = onOff;\n    }\n  }\n};\ngl.prototype.checkIfGridSpotUsable = function (i, j) {\n  if (i == 0 && (j < 2 || j > 4)) {\n    return false;\n  } else if ( i == 1 && ( j == 0 || j == 6)) {\n    return false;\n  } else if ( i == 5 && ( j == 0 || j == 6)) {\n    return false;\n  } else if (i == 6 && ( j < 2 || j > 4)) {\n    return false;\n  } else if ( i < 0 || i > 6 || j < 0 || j > 6) {\n    return false;\n  } else {\n    return true;\n  }\n};\ngl.prototype.marblesLeft = function () {\n  var filledSpaces = 0;\n  var gb = this.gridBlocks;\n  for (let i = 0; i < gb.length; i ++) {\n    for (let j = 0; j < gb[i].length; j ++) {\n      if (gb[i][j].script.gridBlock.isUsed) {\n        filledSpaces++;\n      }\n    }\n  }\n  return filledSpaces;\n};\ngl.prototype.anyMovesLeft = function () {\n  var gb = this.gridBlocks;\n  for (let i = 0; i < gb.length; i ++) {\n    for (let j = 0; j < gb[i].length; j ++) {\n      if (gb[i][j].script.gridBlock.isUsed && this.checkIfGridSpotUsable(i,j)) { // if grid block is on the usable grid and has a marble on it, and is not an edge case\n        // we will check to see if it has any neighbors with a marble on them as well\n        if (this.checkIfGridSpotUsable(i-1,j) && this.checkIfGridSpotUsable(i-2,j)) {\n          // console.log (i + ', ' + j + ' has neighbours ' + (i-1) + ', ' + j + ', and ' + (i-2) + ', ' + j);\n          if (gb[i-1][j].script.gridBlock.isUsed && !gb[i-2][j].script.gridBlock.isUsed) {\n            // console.log (i + ', ' + j + ' is movable');\n            return true;\n          }\n        } \n        if (this.checkIfGridSpotUsable(i+1,j) && this.checkIfGridSpotUsable(i+2,j)) {\n          // console.log (i + ', ' + j + ' has neighbours ' + (i+1) + ', ' + j + ', and ' + (i+2) + ', ' + j);\n          if (gb[i+1][j].script.gridBlock.isUsed && !gb[i+2][j].script.gridBlock.isUsed) {\n            // console.log (i + ', ' + j + ' is movable');\n            return true;\n          }\n        }\n        if (this.checkIfGridSpotUsable(i,j-1) && this.checkIfGridSpotUsable(i,j-2)) {\n          // console.log (i + ', ' + j + ' has neighbours ' + i + ', ' + (j-1) + ', and ' + i + ', ' + (j-2));\n          if (gb[i][j-1].script.gridBlock.isUsed && !gb[i][j-2].script.gridBlock.isUsed) {\n            // console.log (i + ', ' + j + ' is movable');\n            return true;\n          }\n        }\n        if (this.checkIfGridSpotUsable(i,j+1) && this.checkIfGridSpotUsable(i,j+2)) {\n          // console.log (i + ', ' + j + ' has neighbours ' + i + ', ' + (j+1) + ', and ' + i + ', ' + (j+2));\n          if (gb[i][j+1].script.gridBlock.isUsed && !gb[i][j+2].script.gridBlock.isUsed) {\n            // console.log (i + ', ' + j + ' is movable');\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\ngl.prototype.debugGridBlocks = function () {\n  var gb = this.gridBlocks;\n  for (let i = 0; i < gb.length; i ++) {\n    for (let j = 0; j < gb[i].length; j ++) {\n      if (gb[i][j].script.gridBlock.isUsed && gb[i][j].script.gridBlock.isUsable) {\n        gb[i][j].render.enabled = true;\n      } else {\n        gb[i][j].render.enabled = false;\n      }\n    }\n  }\n};\ngl.prototype.turnOffGridBlocksVisibility = function () {\n  var gb = this.gridBlocks;\n  for (let i = 0; i < gb.length; i ++) {\n    for (let j = 0; j < gb[i].length; j ++) {\n      this.toggleGridBlockChildren(gb[i][j], false);\n    }\n  }\n};\ngl.prototype.doRaycast = function (screenX, screenY) {\n  // The pc.Vec3 to raycast from (the position of the camera)\n  var raycastFromPoint = this.mainCam.getPosition();\n  // The pc.Vec3 to raycast to (the click position projected onto the camera's far clip plane)\n  var raycastToPoint = this.mainCam.camera.screenToWorld(screenX, screenY, this.mainCam.camera.farClip);\n  // Raycast between the two points and return the closest hit result\n  var result = this.app.systems.rigidbody.raycastFirst(raycastFromPoint, raycastToPoint);\n  var type = 'non-interactive';\n  if (result != null && result.entity.script) {      \n    if (result.entity.script.marble) {\n      type = 'marble';\n    } else if (result.entity.script.gridBlock) {\n      type = 'gridBlock';\n    }\n  } else {\n    type = 'no contact';\n  }\n  return { result: result, type: type };\n};\n\n\n// MOUSE EVENTS___________________________________________________________________________\ngl.prototype.onMouseUp = function (eventData) {\n  if (this.firstMoveMade) {\n    this.states.event(this, 'clickReleased');\n  } else {\n    this.states.event(this, 'gameStartClickReleased');\n  }\n};\ngl.prototype.onMouseDown = function (mouseData) {\n  // If the left mouse button is pressed, change the cube color to red\n  if (mouseData.button === pc.MOUSEBUTTON_LEFT) {\n    this.mouseClickRaycastResult = this.doRaycast(mouseData.x, mouseData.y);\n    switch (this.mouseClickRaycastResult.type) {\n      case 'marble':\n        this.clickedMarble = this.mouseClickRaycastResult.result.entity;\n        this.lastBlock = this.gridBlocks[this.clickedMarble.script.marble.row][this.clickedMarble.script.marble.col];\n        this.states.event(this, 'marbleClicked');\n        break;\n      case 'gridBlock':\n        this.states.event(this, 'gridClicked');\n        break;\n      case 'emptySpot':\n        this.states.event(this, 'emptySpotClicked');\n        break;\n      default:\n        this.states.event(this, 'bgClicked');\n    }\n  }\n  if (mouseData.button === pc.MOUSEBUTTON_MIDDLE) {\n    console.log('middle mouse button clicked');\n  }\n  if (mouseData.button === pc.MOUSEBUTTON_RIGHT) {\n    console.log('right mouse button clicked');\n  }\n  // console.log('gridBlock clicked, marble id: ' + gridBlock.marbleId + ', row: ' + gridBlock.row + ', column: ' + gridBlock.col + ', is usable: ' + gridBlock.isUsable + ', is free: ' + gridBlock.isUsed );\n  // console.log('marble clicked, id: ' + marble.id + ', row: ' + marble.row + ', column: ' + marble.col + ', is set: ' + marble.isSet + ', is grabbed: ' + marble.isGrabbed );\n};\ngl.prototype.onMouseMove = function (mouseData) {\n    // example how to use the camera component's screenToWorld function to convert the position of the mouse into a position in 3D space\n    this.storeAPosition = new pc.Vec3();\n    var depth = 10;\n    var cameraEntity = this.app.root.findByName('Camera');\n    this.someNewPosition = this.mainCam.camera.screenToWorld(mouseData.x, mouseData.y, depth, this.storeAPosition);\n    this.mousePos = [mouseData.x, mouseData.y];\n};\n\n\n// INITIALIZE code called once per entity_______________________________________________________________________________________________\ngl.prototype.initialize = function() {\n  \n  // SETUP AND LOCAL VARIABLES\n  this.setupAndLocalVariables();\n  this.turnOffGridBlocksVisibility();\n\n  // SETTING UP MOUSE EVENTS___________________________________________________________________\n  // disable right click menus\n  this.app.mouse.disableContextMenu();\n  // Add a mousedown event handler\n  this.app.mouse.on(pc.EVENT_MOUSEDOWN, this.onMouseDown, this);\n  this.app.mouse.on(pc.EVENT_MOUSEUP, this.onMouseUp, this);\n  this.app.mouse.on(pc.EVENT_MOUSEMOVE, this.onMouseMove, this);\n\n\n  // DEBUGGING / CONSOLE LOG ______________________________________________________________________\n};\n\n// update code called every frame\ngl.prototype.update = function(dt) {\n  // this.debugGridBlocks();\n  // State machine updates\n  switch (this.states.state) {\n    case 'gameStart':\n      this.states.gameStart.actions.onUpdate(this);\n      break;\n    case 'idle':\n      this.states.idle.actions.onUpdate(this);\n      break;\n    case 'rotateView':\n      // this.states.rotateView.actions.onUpdate(this);\n      break;\n    case 'marbleSelected':\n      this.states.marbleSelected.actions.onUpdate(this);\n      break;\n    case 'victory':\n      // this.states.victory.actions.onUpdate(this);\n      break;\n    case 'noMoreMoves':\n      // this.states.victory.actions.onUpdate(this);\n      break;\n    default:\n      console.log('something aint right');\n  }\n};    \n\n// swap method called for script hot-reloading\n// inherit your script state here\n// gl.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n","// marble.js\nvar ml = pc.createScript('marble');\n\n\n// initialize code called once per entity\nml.prototype.initialize = function() {\n    this.id = -1;\n    this.col = -1;\n    this.row = -1;\n    this.isSet = false;\n    this.isGrabbed = false;\n    // var thisInstancesMarble = this.entity.findByTag(\"marble\");\n    // var thisInstancesMarble = this.entity.findComponent(\"render\");\n    // console.log(thisInstancesMarble);\n    // thisInstancesMarble.enabled = false;\n};\n\n// update code called every frame\nml.prototype.update = function(dt) {\n\n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// ml.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n","// raycast.js\nvar Raycast = pc.createScript('raycast');\n\n// initialize code called once per entity\nRaycast.prototype.initialize = function() {\n    if (!this.entity.camera) {\n        console.error('This script must be applied to an entity with a camera component.');\n        return;\n    }\n\n    // Add a mousedown event handler\n    this.app.mouse.on(pc.EVENT_MOUSEDOWN, this.mouseDown, this);\n\n    // Add touch event only if touch is available\n    if (this.app.touch) {\n        this.app.touch.on(pc.EVENT_TOUCHSTART, this.touchStart, this);\n    }\n};\n\nRaycast.prototype.mouseDown = function (e) {\n    this.doRaycast(e.x, e.y);\n};\n\nRaycast.prototype.touchStart = function (e) {\n    // Only perform the raycast if there is one finger on the screen\n    if (e.touches.length === 1) {\n        this.doRaycast(e.touches[0].x, e.touches[0].y);\n    }\n    e.event.preventDefault();\n};\n\nRaycast.prototype.doRaycast = function (screenX, screenY) {\n    // The pc.Vec3 to raycast from (the position of the camera)\n    var from = this.entity.getPosition();\n\n    // The pc.Vec3 to raycast to (the click position projected onto the camera's far clip plane)\n    var to = this.entity.camera.screenToWorld(screenX, screenY, this.entity.camera.farClip);\n\n    // Raycast between the two points and return the closest hit result\n    var result = this.app.systems.rigidbody.raycastFirst(from, to);\n\n    // If there was a hit, store the entity\n    if (result) {\n        var hitEntity = result.entity;\n        console.log('You selected ' + hitEntity.name);\n    }\n};\n\n","// hideAtLaunch.js\nvar HideAtlaunch = pc.createScript('hideAtlaunch');\n\n// initialize code called once per entity\nHideAtlaunch.prototype.initialize = function() {\n    this.entity.enabled = false;\n};\n\n// update code called every frame\nHideAtlaunch.prototype.update = function(dt) {\n\n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// HideAtlaunch.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n","// gridBlock.js\nvar GridBlock = pc.createScript('gridBlock');\n\n// initialize code called once per entity\nGridBlock.prototype.initialize = function() {\n    this.isUsed = false;\n    this.isUsable = false;\n    this.marbleId = -1;\n    this.col = -1;\n    this.row = -1;\n};\n\n// update code called every frame\nGridBlock.prototype.update = function(dt) {\n\n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// GridBlock.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n","// platformCollider.js\nvar PlatformCollider = pc.createScript('platformCollider');\n\n// initialize code called once per entity\nPlatformCollider.prototype.initialize = function() {\n\n};\n\n// update code called every frame\nPlatformCollider.prototype.update = function(dt) {\n\n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// PlatformCollider.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n","// history.js\nvar History = pc.createScript('history');\n\n// initialize code called once per entity\nHistory.prototype.initialize = function() {\n\n};\n\n// update code called every frame\nHistory.prototype.update = function(dt) {\n\n};\n\n// swap method called for script hot-reloading\n// inherit your script state here\n// History.prototype.swap = function(old) { };\n\n// to learn more about script anatomy, please read:\n// https://developer.playcanvas.com/en/user-manual/scripting/\n\n"]}